# 2015-11-15

共用体
https://ja.wikipedia.org/wiki/%E5%85%B1%E7%94%A8%E4%BD%93

---

set は一般的に木構造を取るので、探索や演算に対しては、
O(log n)の計算量になる。

Arrayから特定の値の有無をチェックするような演算はO(n)なので、
データ量が莫大な時、圧倒的にsetのほうが、演算量は少なくなる。

---

O(log n)とO(1)の計算量は、実用的にはほとんど変わらない。
故に、hashとsetにおける値の引き出し演算速度は、
基本的に変わらないと考えて良い。
大きいデータ構造を取り扱うときには、
hashのほうが危険になる。

hash(ディレクトリ型)は、キー値をhashに変換して取り扱う、
そのため、データが多くなると、キー値の重複が発生しうる
そうするとO(1) -> O(n)に近づく
とした場合は、木構造をとる型を利用することが安全

さらに、hashは状態変化を伴うので、 危険性がある。
= 参照透過性が担保されない

木構造だと、状態変化がないので、値へのアクセスに対して安全に扱うことができる
= スレッドセーフ(並行・並列にしたときに良い)
= segVとかが起きにくい

故に、参照透過性を保ったまま、実行速度を維持しようとすると木構造






